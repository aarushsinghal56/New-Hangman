<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hangman Game</title>
    <!-- Load Tailwind CSS --><script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Canvas Confetti --><script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <!-- Load Tone.js for Sound --><script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        /* Custom styles for the game */
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(to right bottom, #6366f1, #22d3ee); /* Indigo 500 to Cyan 400 gradient */
            overflow-x: hidden; /* Prevent horizontal scroll */
        }
        /* New: Main layout wrapper */
        .main-layout {
            display: flex;
            justify-content: center; /* This will center the game-container */
            align-items: flex-start;
            width: 100%;
            padding: 1rem; /* p-4 */
            gap: 2rem; /* Add gap for desktop */
        }

        /* Main game container */
        .game-container {
            position: relative;
            max-width: 512px; /* 2xl */
            width: 100%;
            background-color: white;
            border-radius: 1.5rem; /* 2xl */
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            padding: 2.5rem; /* p-10 */
            margin: 0; /* Removed margin */
            z-index: 20; /* Ensure game container is above background but below panels */
        }
        
        /* Style for the hangman SVG parts */
        .hangman-part {
            fill: none;
            stroke: #333;
            stroke-width: 4;
            stroke-linecap: round;
            visibility: hidden;
            transition: visibility 0.3s ease-in-out;
        }
        #gallows-base, #gallows-pole, #gallows-beam, #gallows-rope { visibility: visible; }
        .keyboard-button {
            transition: all 0.15s ease-in-out;
            transform: scale(1);
        }
        .keyboard-button:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        .keyboard-button:active:not(:disabled) {
            transform: scale(0.98);
            background-color: #4f46e5;
            box-shadow: none;
        }
        .keyboard-button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
            background-color: #e0e0e0 !important;
            color: #888 !important;
            box-shadow: none;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4f46e5;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- MOBILE CHAT POPUP STYLES --- */
        #chat-icon-btn {
            position: fixed;
            bottom: 1.5rem; /* 24px */
            right: 1.5rem; /* 24px */
            z-index: 50;
        }
        #chat-popup-mobile {
            position: fixed;
            bottom: 5rem; /* 80px */
            right: 1.5rem; /* 24px */
            width: 300px;
            height: 400px;
            z-index: 40;
            transition: all 0.3s ease-in-out;
            transform-origin: bottom right;
        }
        /* Hide by default */
        #chat-popup-mobile.scale-0 {
            transform: scale(0);
            opacity: 0;
        }
        /* Show */
        #chat-popup-mobile.scale-100 {
            transform: scale(1);
            opacity: 1;
        }
        #chat-messages-mobile {
            scroll-behavior: smooth;
        }
        .emoji-reaction-btn-mobile {
            transition: all 0.15s ease-out;
            font-size: 1.5rem; /* 24px */
        }
        .emoji-reaction-btn-mobile:hover {
            transform: scale(1.25);
        }

        /* --- DESKTOP CHAT WINDOW --- */
        #chat-window-desktop {
            position: fixed;
            top: 5rem; /* More "in-between" spacing */
            right: 5rem; /* More "in-between" spacing */
            width: 320px; /* w-80 */
            height: 700px; /* Fixed height */
            background-color: rgba(239, 246, 255, 0.9); /* blue-50 with opacity */
            border: 1px solid #bfdbfe; /* blue-200 */
            border-radius: 12px;
            padding: 0; /* Remove padding, add to inner elements */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            z-index: 30;
            transition: all 0.3s ease-in-out;
            transform-origin: top right;
            display: flex;
            flex-direction: column;
        }
        #chat-messages-desktop {
            scroll-behavior: smooth;
        }
        .emoji-reaction-btn-desktop {
            transition: all 0.15s ease-out;
            font-size: 1.5rem; /* 24px */
        }
        .emoji-reaction-btn-desktop:hover {
            transform: scale(1.25);
        }


        /* --- EMOJI REACTION STYLES --- */
        #emoji-display-area {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 6rem;
            opacity: 0;
            transition: all 0.5s ease-out;
            z-index: 100;
            pointer-events: none; /* So it doesn't block clicks */
        }
        #emoji-display-area.pop-and-fade {
            animation: popAndFade 2s ease-out forwards;
        }
        @keyframes popAndFade {
            0% { transform: translateX(-50%) scale(0.5); opacity: 0; }
            20% { transform: translateX(-50%) scale(1.2); opacity: 1; }
            40% { transform: translateX(-50%) scale(1); opacity: 1; }
            100% { transform: translateX(-50%) scale(1); opacity: 0; }
        }

        /* Round Selection Buttons */
        .round-btn.selected {
            background-color: #4f46e5; /* indigo-600 */
            color: white;
            border-color: #4f46e5;
        }

        /* Hint Button */
        #hint-btn {
            transition: all 0.2s ease;
        }
        #hint-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #d1d5db; /* gray-300 */
        }

        /* Avatar Customizer */
        .avatar-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        .avatar-button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.5rem;
            color: #4a5568; /* gray-700 */
        }
        .avatar-button:hover {
            color: #2d3748; /* gray-900 */
        }
        .avatar-display {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #333; /* Dark border for visibility */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem; /* For the crown */
            position: relative;
        }
        .avatar-crown {
            position: absolute;
            top: -10px;
            font-size: 1rem;
        }

        /* === NEW PLAYER INFO BOX === */
        #player-info-box {
            position: fixed;
            top: 5rem; /* More "in-between" spacing */
            left: 5rem; /* More "in-between" spacing */
            width: 220px;
            background-color: rgba(239, 246, 255, 0.9); /* blue-50 with opacity */
            border: 1px solid #bfdbfe; /* blue-200 */
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            z-index: 30;
            transition: all 0.3s ease-in-out;
            transform-origin: top left;
        }
        #player-info-box.hidden {
            transform: scale(0.9) translateX(-10%);
            opacity: 0;
            pointer-events: none;
        }
        
        /* Hide on mobile, show old display */
        @media (max-width: 1023px) { /* lg breakpoint */
            #player-info-box {
                display: none !important; /* Force hide on mobile */
            }
            #chat-window-desktop {
                display: none !important; /* Force hide on mobile */
            }
        }
        /* Show on desktop (will be controlled by JS adding/removing 'hidden') */
        @media (min-width: 1024px) { /* lg breakpoint */
            #score-display-mobile {
                display: none;
            }
            #chat-icon-btn {
                display: none; /* Hide mobile chat icon */
            }
            #chat-popup-mobile {
                display: none; /* Hide mobile chat popup */
            }
        }

        #player-info-round {
            text-align: center;
            font-size: 1.125rem; /* xl */
            font-weight: bold;
            color: #374151; /* gray-700 */
            border-bottom: 2px solid #6366f1; /* indigo-500 */
            padding-bottom: 0.75rem;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .player-info-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem;
            border-radius: 8px;
            border: 2px solid transparent;
        }
        .player-info-item.active-player {
            border-color: #6366f1; /* indigo-500 */
            background-color: #fff;
        }
        .player-info-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid #333;
            flex-shrink: 0;
            position: relative;
        }
        .player-info-crown {
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1rem;
            color: #f59e0b; /* amber-500 */
            text-shadow: 0 0 2px rgba(0,0,0,0.5);
        }
        .player-info-name {
            font-weight: 600; /* semibold */
            color: #333;
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .player-info-score {
            font-weight: bold;
            color: #4f46e5; /* indigo-600 */
            font-size: 1.125rem; /* xl */
        }
        
        /* --- FUNKY CLOCK STYLES --- */
        .player-info-timer { /* Desktop */
            text-align: center;
            margin-top: 0.5rem;
            background-color: #fee2e2; /* red-100 */
            padding: 0.5rem;
            border-radius: 8px;
        }
        #timer-display { /* Mobile */
             text-align: right;
        }
        .funky-clock-container {
            position: relative;
            margin-left: auto; /* Aligns to the right for mobile */
            margin-right: 0;
        }
        .funky-clock-hand {
            transform: rotate(0deg);
            transition: transform 1s linear; /* Smooth tick */
        }
        /* Animation class to be added by JS */
        .funky-clock-hand.running {
            animation: clock-tick 150s linear forwards;
        }
        @keyframes clock-tick {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .player-info-timer-text {
            font-family: 'monospace';
            font-weight: bold;
            color: #ef4444; /* red-500 */
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4 text-gray-800">

    <!-- Main layout container -->
    <main class="main-layout">

        <!-- === NEW PLAYER INFO BOX (Desktop) === -->
        <!-- FIXED: Removed md:flex, only 'hidden' is needed -->
        <div id="player-info-box" class="hidden flex-col gap-3">
            <!-- Round -->
            <div id="player-info-round">
                <svg class="w-6 h-6 text-indigo-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg>
                <span>Round 1 / 3</span>
            </div>
            
            <!-- Player 1 (Me) -->
            <div id="player-info-me" class="player-info-item">
                <div id="player-info-me-avatar" class="player-info-avatar" style="background-color: #EF4444;">
                    <div id="player-info-me-crown" class="player-info-crown hidden">üëë</div>
                </div>
                <span id="player-info-me-name" class="player-info-name">You</span>
                <span id="player-info-me-score" class="player-info-score">0</span>
            </div>
            
            <!-- Player 2 (Friend) -->
            <div id="player-info-friend" class="player-info-item">
                <div id="player-info-friend-avatar" class="player-info-avatar" style="background-color: #3B82F6;">
                    <div id="player-info-friend-crown" class="player-info-crown hidden">üëë</div>
                </div>
                <span id="player-info-friend-name" class="player-info-name">Friend</span>
                <span id="player-info-friend-score" class="player-info-score">0</span>
            </div>

            <!-- Timer -->
            <div id="player-info-timer" class="player-info-timer">
                <div class="funky-clock-container relative w-24 h-20 mx-auto">
                    <svg viewBox="0 0 100 100" class="w-full h-full">
                        <!-- Bells -->
                        <circle cx="30" cy="12" r="8" fill="#aaa" />
                        <circle cx="70" cy="12" r="8" fill="#aaa" />
                        <!-- Clock Face -->
                        <circle cx="50" cy="50" r="35" fill="#FEE2E2" stroke="#EF4444" stroke-width="4" />
                        <!-- Clock Hand -->
                        <line id="clock-hand-desktop" class="funky-clock-hand" x1="50" y1="50" x2="50" y2="25" stroke="#333" stroke-width="4" stroke-linecap="round" style="transform-origin: 50% 50%;" />
                        <!-- Center dot -->
                        <circle cx="50" cy="50" r="3" fill="#333" />
                    </svg>
                </div>
                <p id="player-info-timer-text" class="text-center text-3xl player-info-timer-text">02:30</p>
            </div>
        </div>

        <!-- This is the main container for the game -->
        <div class="game-container" id="game-container">
            
            <!-- === Mode Selection Screen === -->
            <div id="mode-selection-screen" class="space-y-6">
                <h1 class="text-4xl font-extrabold text-center text-indigo-700">Hangman Challenge</h1>
                <p class="text-center text-lg text-gray-700">How do you want to play?</p>
                <button id="play-local-btn" class="w-full bg-indigo-600 text-white font-bold py-4 px-6 rounded-xl hover:bg-indigo-700 transition duration-300 shadow-lg text-lg transform hover:scale-[1.02]">
                    Play Locally (Hot-Seat)
                </button>
                <button id="play-online-btn" class="w-full bg-green-600 text-white font-bold py-4 px-6 rounded-xl hover:bg-green-700 transition duration-300 shadow-lg text-lg transform hover:scale-[1.02]">
                    Play Online with Friends
                </button>
            </div>

            <!-- === Local Setup Screen === -->
            <div id="local-setup-screen" class="hidden space-y-8">
                <h1 class="text-3xl font-extrabold text-center text-indigo-700">Local Game</h1>
                <p class="text-center text-gray-700 text-lg">Enter a secret word or phrase. Vowels will be revealed automatically!</p>
                <div>
                    <label for="local-secret-word-input" class="block text-sm font-medium text-gray-700 mb-2">Secret Word</label>
                    <input type="password" id="local-secret-word-input" class="w-full px-5 py-3 border border-gray-300 rounded-xl shadow-inner focus:outline-none focus:ring-3 focus:ring-indigo-400 text-lg" placeholder="e.g., The Matrix">
                </div>
                <button id="start-local-game-btn" class="w-full bg-indigo-600 text-white font-bold py-4 px-6 rounded-xl hover:bg-indigo-700 transition duration-300 shadow-lg text-lg transform hover:scale-[1.02]">
                    Start Local Game
                </button>
                <p id="local-setup-error" class="text-red-600 text-center text-sm hidden mt-4"></p>
                <button id="back-to-modes-local-btn" class="w-full text-center text-gray-600 hover:underline mt-4">Back to Menu</button>
            </div>

            <!-- === Online Setup Screen === -->
            <div id="online-setup-screen" class="hidden space-y-8">
                <h1 class="text-3xl font-extrabold text-center text-indigo-700">Online Game</h1>
                
                <!-- Create Game -->
                <div class="border p-4 rounded-lg space-y-4">
                    <h2 class="text-2xl font-bold text-gray-800 text-center">Create a Game</h2>
                    <div>
                        <label for="create-name-input" class="block text-sm font-medium text-gray-700 mb-2">Your Name</label>
                        <input type="text" id="create-name-input" maxlength="15" class="w-full px-5 py-3 border border-gray-300 rounded-xl shadow-inner focus:outline-none focus:ring-3 focus:ring-indigo-400 text-lg" placeholder="Enter your name">
                    </div>
                    <!-- Avatar for Create -->
                    <div class="avatar-container">
                        <button class="avatar-button" id="create-avatar-prev">&lt;</button>
                        <div class="avatar-display" id="create-avatar-display" style="background-color: #EF4444;"></div>
                        <button class="avatar-button" id="create-avatar-next">&gt;</button>
                    </div>
                    <button id="create-game-btn" class="w-full bg-indigo-600 text-white font-bold py-4 px-6 rounded-xl hover:bg-indigo-700 transition duration-300 shadow-lg text-lg transform hover:scale-[1.02]">
                        Create Game Room
                    </button>
                </div>

                <!-- Join Game -->
                <div class="border p-4 rounded-lg space-y-4">
                    <h2 class="text-2xl font-bold text-gray-800 text-center">Join a Game</h2>
                    <div>
                        <label for="join-name-input" class="block text-sm font-medium text-gray-700 mb-2">Your Name</label>
                        <input type="text" id="join-name-input" maxlength="15" class="w-full px-5 py-3 border border-gray-300 rounded-xl shadow-inner focus:outline-none focus:ring-3 focus:ring-indigo-400 text-lg" placeholder="Enter your name">
                    </div>
                     <!-- Avatar for Join -->
                     <div class="avatar-container">
                        <button class="avatar-button" id="join-avatar-prev">&lt;</button>
                        <div class="avatar-display" id="join-avatar-display" style="background-color: #3B82F6;"></div>
                        <button class="avatar-button" id="join-avatar-next">&gt;</button>
                    </div>
                    <div>
                        <label for="join-game-id" class="block text-sm font-medium text-gray-700 mb-2">Game ID</label>
                        <input type="text" id="join-game-id" class="w-full px-5 py-3 border border-gray-300 rounded-xl shadow-inner focus:outline-none focus:ring-3 focus:ring-indigo-400 text-lg" placeholder="Enter Game ID">
                    </div>
                    <button id="join-game-btn" class="w-full bg-green-600 text-white font-bold py-4 px-6 rounded-xl hover:bg-green-700 transition duration-300 shadow-lg text-lg transform hover:scale-[1.02]">
                        Join Game
                    </button>
                </div>
                
                <p id="setup-error" class="text-red-600 text-center text-sm hidden mt-4"></p>
                <p id="user-id-display" class="text-center text-gray-500 text-xs break-all"></p>
                <button id="back-to-modes-online-btn" class="w-full text-center text-gray-600 hover:underline mt-4">Back to Menu</button>
            </div>

            <!-- === Round Selection Screen === -->
            <div id="round-selection-screen" class="hidden space-y-6">
                <h1 class="text-3xl font-extrabold text-center text-indigo-700">Set Match Length</h1>
                <p class="text-center text-gray-700 text-lg">Choose how many rounds you want to play.</p>
                <div class="space-y-3">
                    <button data-rounds="3" class="round-btn w-full text-lg border-2 border-gray-300 text-gray-800 font-bold py-4 px-6 rounded-xl hover:bg-gray-100 transition">
                        Quick Match (Best of 3)
                    </button>
                    <button data-rounds="7" class="round-btn w-full text-lg border-2 border-gray-300 text-gray-800 font-bold py-4 px-6 rounded-xl hover:bg-gray-100 transition">
                        Normal Match (Best of 7)
                    </button>
                </div>
                <!-- Custom Match -->
                <div class="space-y-2">
                    <button data-rounds="custom" class="round-btn w-full text-lg border-2 border-gray-300 text-gray-800 font-bold py-4 px-6 rounded-xl hover:bg-gray-100 transition">
                        Custom Match
                    </button>
                    <input type="number" id="custom-rounds-input" min="1" max="99" class="hidden w-full px-5 py-3 border border-gray-300 rounded-xl shadow-inner focus:outline-none focus:ring-3 focus:ring-indigo-400 text-lg" placeholder="Enter total rounds (e.g., 5)">
                </div>
                <button id="set-rounds-btn" class="w-full bg-indigo-600 text-white font-bold py-4 px-6 rounded-xl hover:bg-indigo-700 transition duration-300 shadow-lg text-lg transform hover:scale-[1.02]">
                    Start Match
                </button>
                <p id="round-error" class="text-red-600 text-center text-sm hidden mt-4"></p>
            </div>


            <!-- === Waiting Screen === -->
            <div id="waiting-screen" class="hidden text-center space-y-6">
                <h1 class="text-3xl font-extrabold text-center text-indigo-700">Game Created!</h1>
                <p class="text-lg text-gray-700">Share this code with your friend:</p>
                
                <!-- Share Code -->
                <div class="bg-gray-100 p-4 rounded-lg shadow-inner">
                    <label for="game-id-display" class="block text-sm font-medium text-gray-700 mb-2">Game Code</label>
                    <div class="flex">
                        <input id="game-id-display" type="text" readonly class="w-full text-center text-2xl font-bold bg-white border border-gray-300 rounded-l-lg text-gray-800" value="Loading...">
                        <button id="copy-game-id-btn" class="bg-indigo-500 text-white font-bold py-2 px-4 rounded-r-lg hover:bg-indigo-600 transition">Copy</button>
                    </div>
                </div>

                <p class="text-lg text-gray-700">Waiting for a friend to join...</p>
                <div class="loader"></div>
                <button id="cancel-game-btn" class="text-sm text-red-600 hover:underline">Cancel Game</button>
            </div>

            <!-- === Set Word Screen (Online) === -->
            <div id="set-word-screen" class="hidden space-y-8">
                <h1 class="text-3xl font-extrabold text-center text-indigo-700">Your Turn!</h1>
                <p class="text-center text-gray-700 text-lg">Enter a secret word for your friend to guess. Vowels will be revealed.</p>
                <div>
                    <label for="online-secret-word-input" class="block text-sm font-medium text-gray-700 mb-2">Secret Word</label>
                    <input type="password" id="online-secret-word-input" class="w-full px-5 py-3 border border-gray-300 rounded-xl shadow-inner focus:outline-none focus:ring-3 focus:ring-indigo-400 text-lg" placeholder="e.g., The Matrix">
                </div>
                <button id="set-online-word-btn" class="w-full bg-indigo-600 text-white font-bold py-4 px-6 rounded-xl hover:bg-indigo-700 transition duration-300 shadow-lg text-lg transform hover:scale-[1.02]">
                    Set Word
                </button>
                <p id="set-word-error" class="text-red-600 text-center text-sm hidden mt-4"></p>
            </div>

            <!-- === Wait for Word Screen (Online) === -->
            <div id="wait-for-word-screen" class="hidden text-center space-y-6">
                <h1 class="text-3xl font-extrabold text-center text-indigo-700">Get Ready!</h1>
                <p class="text-lg text-gray-700">Your friend is picking a secret word...</p>
                <div class="loader"></div>
            </div>

            <!-- === Game Screen === -->
            <div id="game-screen" class="hidden">
                <!-- This is the container for the game elements -->
                <div class="game-area-wrapper">
                    <!-- Mobile Score/Timer Display (Hidden on Desktop) -->
                    <div id="score-display-mobile" class="flex md:hidden justify-between items-start mb-4">
                        <!-- Score & Round Display -->
                        <div id="score-display" class="text-left">
                            <h2 class="text-xl font-bold text-indigo-700">Score</h2>
                            <p id="score-text" class="text-lg text-gray-700">You: 0 - Friend: 0</p>
                            <p id="round-text" class="text-sm text-gray-500">Round 1 / 3</p>
                        </div>
                        <!-- Timer Display -->
                        <div id="timer-display" class="text-right">
                            <h2 class="text-xl font-bold text-red-600">Time Left</h2>
                            <!-- Funky Clock (Mobile) -->
                            <div class="funky-clock-container relative w-20 h-16 mx-auto mr-0">
                                <svg viewBox="0 0 100 100" class="w-full h-full">
                                    <circle cx="30" cy="12" r="8" fill="#aaa" />
                                    <circle cx="70" cy="12" r="8" fill="#aaa" />
                                    <circle cx="50" cy="50" r="35" fill="#FEE2E2" stroke="#EF4444" stroke-width="4" />
                                    <line id="clock-hand-mobile" class="funky-clock-hand" x1="50" y1="50" x2="50" y2="25" stroke="#333" stroke-width="4" stroke-linecap="round" style="transform-origin: 50% 50%;" />
                                    <circle cx="50" cy="50" r="3" fill="#333" />
                                </svg>
                            </div>
                            <p id="timer-text" class="text-lg player-info-timer-text text-gray-700">02:30</p>
                        </div>
                    </div>

                    <h1 class="text-4xl font-extrabold text-center text-indigo-700 mb-4">Guess the Word!</h1>
                    
                    <!-- Hangman Drawing -->
                    <div class="flex justify-center mb-4 bg-gray-50 p-4 rounded-lg shadow-inner">
                        <svg height="250" width="200" viewBox="0 0 200 250">
                            <line id="gallows-base" x1="10" y1="230" x2="130" y2="230" class="hangman-part" style="stroke: #5a67d8;" />
                            <line id="gallows-pole" x1="70" y1="230" x2="70" y2="20" class="hangman-part" style="stroke: #5a67d8;" />
                            <line id="gallows-beam" x1="70" y1="20" x2="170" y2="20" class="hangman-part" style="stroke: #5a67d8;" />
                            <line id="gallows-rope" x1="170" y1="20" x2="170" y2="50" class="hangman-part" style="stroke: #ef4444;" />
                            <circle id="head" cx="170" cy="70" r="20" class="hangman-part" style="stroke: #ef4444; fill: #fee2e2;" />
                            <line id="body" x1="170" y1="90" x2="170" y2="150" class="hangman-part" style="stroke: #ef4444;" />
                            <line id="arm-left" x1="170" y1="110" x2="140" y2="130" class="hangman-part" style="stroke: #ef4444;" />
                            <line id="arm-right" x1="170" y1="110" x2="200" y2="130" class="hangman-part" style="stroke: #ef4444;" />
                            <line id="leg-left" x1="170" y1="150" x2="140" y2="180" class="hangman-part" style="stroke: #ef4444;" />
                            <line id="leg-right" x1="170" y1="150" x2="200" y2="180" class="hangman-part" style="stroke: #ef4444;" />
                        </svg>
                    </div>

                    <!-- Word Display -->
                    <div id="word-display" class="flex justify-center flex-wrap gap-x-3 md:gap-x-4 gap-y-2 mb-4 p-3 bg-indigo-50 rounded-lg shadow-inner text-indigo-900">
                    </div>

                    <!-- Wrong Guesses -->
                    <div class="mb-4 text-center bg-red-50 p-3 rounded-lg shadow-inner">
                        <h2 class="text-base font-semibold text-red-700 uppercase tracking-wide">Wrong Guesses:</h2>
                        <p id="wrong-guesses-display" class="text-2xl font-extrabold text-red-800 h-8 mt-1"></p>
                    </div>

                    <!-- Keyboard or Spectator View -->
                    <div id="keyboard-area" class="min-h-[160px]">
                        <!-- Hint Button -->
                        <div id="hint-area" class="text-center mb-4 hidden">
                            <button id="hint-btn" class="bg-yellow-400 text-yellow-900 font-bold py-2 px-5 rounded-full shadow-lg hover:bg-yellow-500">
                                üí° Get Hint (1 left)
                            </button>
                        </div>
                        <!-- Keyboard -->
                        <div id="keyboard-buttons" class="flex flex-wrap justify-center gap-2 md:gap-3">
                        </div>
                        <!-- Spectator View -->
                        <div id="spectator-view" class="hidden text-center text-gray-700">
                            <p class="text-lg font-semibold">Your friend is guessing...</p>
                            <p class="text-sm">You can chat or send reactions!</p>
                        </div>
                    </div>


                    <!-- Game Over Message -->
                    <div id="game-message" class="text-center mt-6 space-y-5 hidden">
                        <h2 id="message-text" class="text-5xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-cyan-500 to-blue-500 animate-pulse"></h2>
                        <button id="play-again-btn" class="bg-indigo-600 text-white font-bold py-3 px-8 rounded-full hover:bg-indigo-700 transition duration-300 shadow-xl text-xl transform hover:scale-[1.05]">
                            Play Again
                        </button>
                    </div>
                </div>
            </div>


            <!-- === Leaderboard Screen === -->
            <div id="leaderboard-screen" class="hidden text-center space-y-6">
                <h1 class="text-4xl font-extrabold text-center text-indigo-700">Match Over!</h1>
                <div id="winner-announcement" class="text-3xl font-bold text-green-600"></div>
                <div class="bg-gray-100 p-6 rounded-lg shadow-inner space-y-4">
                    <h2 class="text-2xl font-bold text-gray-800">Final Score</h2>
                    <!-- Leaderboard Scores -->
                    <div id="final-score-1" class="flex items-center justify-center gap-3 text-xl text-gray-700">
                        <div id="final-avatar-1" class="avatar-display w-8 h-8" style="background-color: #EF4444;"></div>
                        <span id="final-name-1">Player 1</span>:
                        <span id="final-score-val-1" class="font-bold">0</span>
                    </div>
                    <div id="final-score-2" class="flex items-center justify-center gap-3 text-xl text-gray-700">
                        <div id="final-avatar-2" class="avatar-display w-8 h-8" style="background-color: #3B82F6;"></div>
                        <span id="final-name-2">Player 2</span>:
                        <span id="final-score-val-2" class="font-bold">0</span>
                    </div>
                </div>
                <!-- NEW: Rematch buttons -->
                <button id="play-again-match-btn" class="w-full bg-green-600 text-white font-bold py-4 px-6 rounded-xl hover:bg-green-700 transition duration-300 shadow-lg text-lg transform hover:scale-[1.02] hidden">
                    Play Another Match
                </button>
                <div id="waiting-for-host-rematch" class="text-center text-lg text-gray-700 font-semibold hidden">
                    Waiting for host to start a new match...
                </div>
                <button id="main-menu-btn" class="w-full bg-gray-500 text-white font-bold py-4 px-6 rounded-xl hover:bg-gray-600 transition duration-300 shadow-lg text-lg transform hover:scale-[1.02]">
                    Leave Room
                </button>
                <p id="leaderboard-error" class="text-red-600 text-center text-sm hidden mt-4"></p>
            </div>

        </div>

        <!-- === DESKTOP CHAT WINDOW === -->
        <!-- FIXED: Removed md:flex, only 'hidden' is needed -->
        <div id="chat-window-desktop" class="hidden flex-col overflow-hidden">
            <!-- Chat Header -->
            <div class="flex-shrink-0 flex justify-between items-center p-3 bg-indigo-600 text-white rounded-t-lg">
                <h3 class="font-bold text-lg">Game Chat</h3>
            </div>
            
            <!-- Chat Messages -->
            <div id="chat-messages-desktop" class="flex-1 p-3 space-y-3 overflow-y-auto bg-gray-50">
                <!-- Messages will be injected here -->
            </div>

            <!-- Emoji Reactions -->
            <div class="flex-shrink-0 p-2 bg-gray-100 border-t border-b border-gray-200">
                <div id="emoji-reaction-bar-desktop" class="flex justify-around">
                    <button class="emoji-reaction-btn-desktop p-1" data-emoji="üëç">üëç</button>
                    <button class="emoji-reaction-btn-desktop p-1" data-emoji="üòÇ">üòÇ</button>
                    <button class="emoji-reaction-btn-desktop p-1" data-emoji="üòÆ">üòÆ</button>
                    <button class="emoji-reaction-btn-desktop p-1" data-emoji="üëè">üëè</button>
                    <button class="emoji-reaction-btn-desktop p-1" data-emoji="üò¨">üò¨</button>
                </div>
            </div>

            <!-- Chat Input -->
            <form id="chat-form-desktop" class="flex-shrink-0 flex p-3 border-t border-gray-200">
                <input id="chat-input-desktop" type="text" class="flex-1 border border-gray-300 rounded-l-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-400" placeholder="Type a message..." autocomplete="off">
                <button type="submit" class="bg-indigo-600 text-white px-4 py-2 rounded-r-lg font-semibold hover:bg-indigo-700">Send</button>
            </form>
        </div>
    </main>


    <!-- === CHAT ICON (Mobile) === -->
    <button id="chat-icon-btn" class="hidden w-16 h-16 bg-indigo-600 text-white rounded-full md:hidden items-center justify-center shadow-lg transition-transform transform hover:scale-110 z-50">
        <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"></path></svg>
    </button>

    <!-- === CHAT POPUP (Mobile) === -->
    <div id="chat-popup-mobile" class="hidden scale-0 md:hidden flex-col bg-white border border-gray-300 rounded-xl shadow-2xl overflow-hidden">
        <!-- Chat Header -->
        <div class="flex justify-between items-center p-3 bg-indigo-600 text-white">
            <h3 class="font-bold text-lg">Game Chat</h3>
            <button id="chat-close-btn" class="text-white hover:text-gray-200">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
        
        <!-- Chat Messages -->
        <div id="chat-messages-mobile" class="flex-1 p-3 space-y-3 overflow-y-auto bg-gray-50">
            <!-- Messages will be injected here -->
        </div>

        <!-- Emoji Reactions -->
        <div class="p-2 bg-gray-100 border-t border-gray-200">
            <div id="emoji-reaction-bar-mobile" class="flex justify-around">
                <button class="emoji-reaction-btn-mobile p-1" data-emoji="üëç">üëç</button>
                <button class="emoji-reaction-btn-mobile p-1" data-emoji="üòÇ">üòÇ</button>
                <button class="emoji-reaction-btn-mobile p-1" data-emoji="üòÆ">üòÆ</button>
                <button class="emoji-reaction-btn-mobile p-1" data-emoji="üëè">üëè</button>
                <button class="emoji-reaction-btn-mobile p-1" data-emoji="üò¨">üò¨</button>
            </div>
        </div>

        <!-- Chat Input -->
        <form id="chat-form-mobile" class="flex p-3 border-t border-gray-200">
            <input id="chat-input-mobile" type="text" class="flex-1 border border-gray-300 rounded-l-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-400" placeholder="Type a message..." autocomplete="off">
            <button type="submit" class="bg-indigo-600 text-white px-4 py-2 rounded-r-lg font-semibold hover:bg-indigo-700">Send</button>
        </form>
    </div>

    <!-- === EMOJI DISPLAY AREA === -->
    <div id="emoji-display-area" class=""></div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            signInAnonymously, 
            onAuthStateChanged 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            setDoc, 
            getDoc, 
            addDoc,
            updateDoc, 
            deleteDoc,
            onSnapshot, 
            collection,
            query,
            orderBy,
            serverTimestamp,
            setLogLevel
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Wait for the DOM to be fully loaded before running any script
        document.addEventListener('DOMContentLoaded', () => {

            // --- FIREBASE CONFIGURATION (MANUALLY INSERTED) ---
            const firebaseConfig = {
                apiKey: "AIzaSyA7s5i4dmBWD0Qtzn6wvOjFuTbbRd9Z1ys",
                authDomain: "new-game-8ba29.firebaseapp.com",
                projectId: "new-game-8ba29",
                storageBucket: "new-game-8ba29.firebasestorage.app",
                messagingSenderId: "788607615409",
                appId: "1:788607615409:web:a812b8d059333523dfbd90"
            };
            const appId = firebaseConfig.projectId;


            // --- DOM Elements ---
            const gameContainer = document.getElementById('game-container'); // Get main container
            const modeSelectionScreen = document.getElementById('mode-selection-screen');
            const localSetupScreen = document.getElementById('local-setup-screen');
            const onlineSetupScreen = document.getElementById('online-setup-screen');
            const roundSelectionScreen = document.getElementById('round-selection-screen');
            const waitingScreen = document.getElementById('waiting-screen');
            const setWordScreen = document.getElementById('set-word-screen');
            const waitForWordScreen = document.getElementById('wait-for-word-screen');
            const gameScreen = document.getElementById('game-screen');
            const leaderboardScreen = document.getElementById('leaderboard-screen');
            
            // Mode buttons
            const playLocalBtn = document.getElementById('play-local-btn');
            const playOnlineBtn = document.getElementById('play-online-btn');

            // Local setup
            const localSecretWordInput = document.getElementById('local-secret-word-input');
            const startLocalGameBtn = document.getElementById('start-local-game-btn');
            const localSetupError = document.getElementById('local-setup-error');
            const backToModesLocalBtn = document.getElementById('back-to-modes-local-btn');

            // Online setup
            const createNameInput = document.getElementById('create-name-input');
            const createGameBtn = document.getElementById('create-game-btn');
            const joinNameInput = document.getElementById('join-name-input');
            const joinGameIdInput = document.getElementById('join-game-id');
            const joinGameBtn = document.getElementById('join-game-btn');
            const setupError = document.getElementById('setup-error');
            const userIdDisplay = document.getElementById('user-id-display');
            const backToModesOnlineBtn = document.getElementById('back-to-modes-online-btn');

            // Avatar Pickers
            const createAvatarPrev = document.getElementById('create-avatar-prev');
            const createAvatarDisplay = document.getElementById('create-avatar-display');
            const createAvatarNext = document.getElementById('create-avatar-next');
            const joinAvatarPrev = document.getElementById('join-avatar-prev');
            const joinAvatarDisplay = document.getElementById('join-avatar-display');
            const joinAvatarNext = document.getElementById('join-avatar-next');

            // Round Selection
            const roundButtons = document.querySelectorAll('.round-btn');
            const customRoundsInput = document.getElementById('custom-rounds-input');
            const setRoundsBtn = document.getElementById('set-rounds-btn');
            const roundError = document.getElementById('round-error');

            // Set Word (Online)
            const onlineSecretWordInput = document.getElementById('online-secret-word-input');
            const setOnlineWordBtn = document.getElementById('set-online-word-btn');
            const setWordError = document.getElementById('set-word-error');

            // Waiting screen
            const gameIdDisplay = document.getElementById('game-id-display');
            const copyGameIdBtn = document.getElementById('copy-game-id-btn');
            const cancelGameBtn = document.getElementById('cancel-game-btn');
            
            // Game screen
            const scoreDisplayMobile = document.getElementById('score-display-mobile');
            const scoreDisplay = document.getElementById('score-display');
            const scoreText = document.getElementById('score-text');
            const roundText = document.getElementById('round-text');
            const timerDisplay = document.getElementById('timer-display');
            const timerText = document.getElementById('timer-text');
            const clockHandMobile = document.getElementById('clock-hand-mobile');
            
            // New Player Info Box (Desktop)
            const playerInfoBox = document.getElementById('player-info-box');
            const playerInfoRound = document.getElementById('player-info-round');
            const playerInfoMe = document.getElementById('player-info-me');
            const playerInfoMeAvatar = document.getElementById('player-info-me-avatar');
            const playerInfoMeCrown = document.getElementById('player-info-me-crown');
            const playerInfoMeName = document.getElementById('player-info-me-name');
            const playerInfoMeScore = document.getElementById('player-info-me-score');
            const playerInfoFriend = document.getElementById('player-info-friend');
            const playerInfoFriendAvatar = document.getElementById('player-info-friend-avatar');
            const playerInfoFriendCrown = document.getElementById('player-info-friend-crown');
            const playerInfoFriendName = document.getElementById('player-info-friend-name');
            const playerInfoFriendScore = document.getElementById('player-info-friend-score');
            const playerInfoTimer = document.getElementById('player-info-timer');
            const playerInfoTimerText = document.getElementById('player-info-timer-text');
            const clockHandDesktop = document.getElementById('clock-hand-desktop');

            // Game components
            const wordDisplay = document.getElementById('word-display');
            const keyboardArea = document.getElementById('keyboard-area');
            const hintArea = document.getElementById('hint-area');
            const hintBtn = document.getElementById('hint-btn');
            const keyboardButtons = document.getElementById('keyboard-buttons');
            const spectatorView = document.getElementById('spectator-view');
            const wrongGuessesDisplay = document.getElementById('wrong-guesses-display');
            const gameMessage = document.getElementById('game-message');
            const messageText = document.getElementById('message-text');
            const playAgainBtn = document.getElementById('play-again-btn');

            // Leaderboard
            const winnerAnnouncement = document.getElementById('winner-announcement');
            const finalAvatar1 = document.getElementById('final-avatar-1');
            const finalName1 = document.getElementById('final-name-1');
            const finalScoreVal1 = document.getElementById('final-score-val-1');
            const finalAvatar2 = document.getElementById('final-avatar-2');
            const finalName2 = document.getElementById('final-name-2');
            const finalScoreVal2 = document.getElementById('final-score-val-2');
            const mainMenuBtn = document.getElementById('main-menu-btn');
            const playAgainMatchBtn = document.getElementById('play-again-match-btn');
            const waitingForHostRematch = document.getElementById('waiting-for-host-rematch');
            const leaderboardError = document.getElementById('leaderboard-error');

            // Chat (Mobile)
            const chatToggleBtn = document.getElementById('chat-icon-btn');
            const chatPopupMobile = document.getElementById('chat-popup-mobile');
            const chatCloseBtn = document.getElementById('chat-close-btn');
            const chatMessagesMobile = document.getElementById('chat-messages-mobile');
            const chatFormMobile = document.getElementById('chat-form-mobile');
            const chatInputMobile = document.getElementById('chat-input-mobile');
            const emojiReactionBarMobile = document.getElementById('emoji-reaction-bar-mobile');

            // Chat (Desktop)
            const chatWindowDesktop = document.getElementById('chat-window-desktop');
            const chatMessagesDesktop = document.getElementById('chat-messages-desktop');
            const chatFormDesktop = document.getElementById('chat-form-desktop');
            const chatInputDesktop = document.getElementById('chat-input-desktop');
            const emojiReactionBarDesktop = document.getElementById('emoji-reaction-bar-desktop');

            // Emoji Reaction Display
            const emojiDisplayArea = document.getElementById('emoji-display-area');

            const hangmanParts = ['head', 'body', 'arm-left', 'arm-right', 'leg-left', 'leg-right'];

            // --- Game State ---
            let gameMode = 'local'; // 'local' or 'online'
            let secretWord = '';
            let guessedLetters = [];
            let wrongGuesses = 0;
            const maxWrongGuesses = 6;
            const vowels = ['A', 'E', 'I', 'O', 'U'];
            const consonants = 'BCDFGHJKLMNPQRSTVWXYZ'.split('');
            const emojiList = ['üëç', 'üòÇ', 'üòÆ', 'üëè', 'üò¨'];
            const ROUND_DURATION = 150 * 1000; // 2.5 minutes in ms
            let selectedRounds = 3; // Default

            // Avatar colors
            const avatarColors = ['#EF4444', '#3B82F6', '#10B981', '#F59E0B', '#8B5CF6', '#EC4899'];
            let createAvatarIndex = 0;
            let joinAvatarIndex = 1;

            // --- Firebase State ---
            let app, auth, db;
            let userId;
            let currentGameId = null;
            let isGameCreator = false; // Tracks if this client created the room
            let currentRoomData = {}; // Caches the latest room data
            let gameUnsubscribe = null;
            let chatUnsubscribe = null;
            let isFirebaseInitialized = false;
            let roundTimerInterval = null;

            // --- Sound Effects (Tone.js) ---
            let correctSound, wrongSound, winSound, loseSound;
            let audioInitialized = false;

            function initializeAudio() {
                if (audioInitialized || typeof Tone === 'undefined') return;
                try {
                    correctSound = new Tone.Synth().toDestination();
                    wrongSound = new Tone.Synth().toDestination();
                    winSound = new Tone.PolySynth(Tone.Synth).toDestination();
                    loseSound = new Tone.PolySynth(Tone.Synth).toDestination();
                    audioInitialized = true;
                } catch (e) {
                    console.error("Failed to initialize Tone.js:", e);
                }
            }

            async function playSound(soundType) {
                if (!audioInitialized) return;
                
                if (Tone.context.state !== 'running') {
                    await Tone.start();
                }

                const now = Tone.now();
                try {
                    if (soundType === 'correct') {
                        correctSound.triggerAttackRelease("C5", "8n", now);
                    } else if (soundType === 'wrong') {
                        wrongSound.triggerAttackRelease("E3", "8n", now);
                    } else if (soundType === 'win') {
                        winSound.triggerAttackRelease(["C4", "E4", "G4", "C5"], "0.5s", now);
                    } else if (soundType === 'lose') {
                        loseSound.triggerAttackRelease(["C3", "G3", "Eb3"], "1s", now);
                    }
                } catch (e) {
                    console.error("Tone.js error:", e);
                }
            }
            
            // --- Firebase Init ---
            async function initializeFirebase() {
                if (isFirebaseInitialized) {
                    enableOnlineButtons();
                    return;
                }
                try {
                    app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    auth = getAuth(app);
                    setLogLevel('Debug');
                    isFirebaseInitialized = true;

                    onAuthStateChanged(auth, async (user) => {
                        if (user) {
                            userId = user.uid;
                            userIdDisplay.textContent = `Your User ID: ${userId}`;
                            enableOnlineButtons();
                        } else {
                            try {
                                await signInAnonymously(auth);
                            } catch (authError) {
                                showError("Authentication failed. Online features are disabled.");
                                disableOnlineButtons();
                            }
                        }
                    });
                } catch (e) {
                    showError("Error initializing Firebase. Are you online? This mode only works on a live server.");
                    disableOnlineButtons();
                }
            }
            
            function showError(message, onSetup = true) {
                let errorP;
                // Determine which error field to show
                if (gameMode === 'local') {
                    errorP = localSetupError;
                } else if (currentRoomData && currentRoomData.gameState === 'setting_rounds') {
                    errorP = roundError;
                } else if (currentRoomData && currentRoomData.gameState === 'waiting_for_word') {
                    errorP = setWordError;
                } else if (currentRoomData && currentRoomData.gameState === 'leaderboard') {
                    errorP = leaderboardError;
                } else if (onSetup) {
                    errorP = setupError;
                } else {
                    errorP = setupError; // Fallback
                }
                
                if(errorP) {
                    errorP.textContent = message;
                    errorP.classList.remove('hidden');
                }
            }

            function hideAllErrors() {
                if (localSetupError) localSetupError.classList.add('hidden');
                if (setupError) setupError.classList.add('hidden');
                if (roundError) roundError.classList.add('hidden');
                if (setWordError) setWordError.classList.add('hidden');
                if (leaderboardError) leaderboardError.classList.add('hidden');
            }

            function hideAllScreens() {
                gameContainer.classList.remove('in-game'); // Remove special padding
                modeSelectionScreen.classList.add('hidden');
                localSetupScreen.classList.add('hidden');
                onlineSetupScreen.classList.add('hidden');
                roundSelectionScreen.classList.add('hidden');
                waitingScreen.classList.add('hidden');
                setWordScreen.classList.add('hidden');
                waitForWordScreen.classList.add('hidden');
                gameScreen.classList.add('hidden');
                leaderboardScreen.classList.add('hidden');
                
                // Hide all panels
                chatToggleBtn.classList.add('hidden');
                chatToggleBtn.style.display = 'none';
                chatPopupMobile.classList.add('scale-0');
                chatPopupMobile.classList.add('hidden');
                chatPopupMobile.style.display = 'none';
                chatWindowDesktop.classList.add('hidden');
                chatWindowDesktop.style.display = 'none';
                playerInfoBox.classList.add('hidden');
                
                timerDisplay.classList.add('hidden');
                scoreDisplayMobile.classList.add('hidden'); // Hide mobile score display
                hideAllErrors();
            }

            function showGameScreens() {
                // Mobile
                chatToggleBtn.classList.remove('hidden');
                chatToggleBtn.style.display = 'flex'; // Use flex for icon
                scoreDisplayMobile.classList.remove('hidden');
                // Desktop
                playerInfoBox.classList.remove('hidden');
                chatWindowDesktop.classList.remove('hidden');
                chatWindowDesktop.style.display = 'flex'; // Use flex for column
            }

            function disableOnlineButtons() {
                createGameBtn.disabled = true;
                joinGameBtn.disabled = true;
                createGameBtn.classList.add('opacity-50','cursor-not-allowed');
                joinGameBtn.classList.add('opacity-50','cursor-not-allowed');
            }
            function enableOnlineButtons() {
                createGameBtn.disabled = false;
                joinGameBtn.disabled = false;
                createGameBtn.classList.remove('opacity-50','cursor-not-allowed');
                joinGameBtn.classList.remove('opacity-50','cursor-not-allowed');
            }

            // --- Event Listeners ---
            playLocalBtn.addEventListener('click', () => {
                gameMode = 'local';
                hideAllScreens();
                localSetupScreen.classList.remove('hidden');
            });
            
            playOnlineBtn.addEventListener('click', () => {
                gameMode = 'online';
                hideAllScreens();
                onlineSetupScreen.classList.remove('hidden');
                initializeFirebase();
            });

            startLocalGameBtn.addEventListener('click', () => {
                initializeAudio(); // Start audio on user interaction
                startLocalGame();
            });
            backToModesLocalBtn.addEventListener('click', resetGame);
            backToModesOnlineBtn.addEventListener('click', resetGame);
            mainMenuBtn.addEventListener('click', resetGame);
            playAgainMatchBtn.addEventListener('click', startNewMatch); // New listener for rematch

            // Online listeners
            createGameBtn.addEventListener('click', () => {
                initializeAudio(); // Start audio on user interaction
                createGame();
            });
            joinGameBtn.addEventListener('click', () => {
                initializeAudio(); // Start audio on user interaction
                joinGame();
            });
            setOnlineWordBtn.addEventListener('click', setOnlineWord);
            cancelGameBtn.addEventListener('click', cancelGame);
            copyGameIdBtn.addEventListener('click', () => copyToClipboard(gameIdDisplay.value, copyGameIdBtn, 'Copy'));
            playAgainBtn.addEventListener('click', handlePlayAgain);
            hintBtn.addEventListener('click', handleHintRequest);

            // Avatar Pickers
            function updateAvatar(display, index) {
                display.style.backgroundColor = avatarColors[index];
            }
            createAvatarPrev.addEventListener('click', () => {
                createAvatarIndex = (createAvatarIndex - 1 + avatarColors.length) % avatarColors.length;
                updateAvatar(createAvatarDisplay, createAvatarIndex);
            });
            createAvatarNext.addEventListener('click', () => {
                createAvatarIndex = (createAvatarIndex + 1) % avatarColors.length;
                updateAvatar(createAvatarDisplay, createAvatarIndex);
            });
            joinAvatarPrev.addEventListener('click', () => {
                joinAvatarIndex = (joinAvatarIndex - 1 + avatarColors.length) % avatarColors.length;
                updateAvatar(joinAvatarDisplay, joinAvatarIndex);
            });
            joinAvatarNext.addEventListener('click', () => {
                joinAvatarIndex = (joinAvatarIndex + 1) % avatarColors.length;
                updateAvatar(joinAvatarDisplay, joinAvatarIndex);
            });

            // Round selection listeners
            roundButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    roundButtons.forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    selectedRounds = btn.dataset.rounds;
                    if (selectedRounds === 'custom') {
                        customRoundsInput.classList.remove('hidden');
                    } else {
                        customRoundsInput.classList.add('hidden');
                    }
                });
            });
            setRoundsBtn.addEventListener('click', setRounds);


            // Input sanitization
            function sanitizeSecretWordInput(event) {
                const regex = /[^A-Za-z ]/g;
                event.target.value = event.target.value.replace(regex, '');
            }
            localSecretWordInput.addEventListener('input', sanitizeSecretWordInput);
            onlineSecretWordInput.addEventListener('input', sanitizeSecretWordInput);

            // Chat listeners
            chatToggleBtn.addEventListener('click', toggleChatPopup);
            chatCloseBtn.addEventListener('click', toggleChatPopup);
            chatFormMobile.addEventListener('submit', handleChatSubmit);
            emojiReactionBarMobile.addEventListener('click', handleEmojiClick);
            chatFormDesktop.addEventListener('submit', handleChatSubmit);
            emojiReactionBarDesktop.addEventListener('click', handleEmojiClick);

            // --- URL Handling ---
            function checkUrlForGameId() {
                // This feature was removed as requested.
            }

            // --- LOCAL GAME FUNCTIONS ---
            function startLocalGame() {
                const word = localSecretWordInput.value.trim().toUpperCase();
                if (!validateWord(word)) return;
                secretWord = word;
                guessedLetters = [...vowels];
                wrongGuesses = 0;
                localSecretWordInput.value = '';
                hideAllScreens();
                gameScreen.classList.remove('hidden');
                scoreDisplayMobile.classList.add('hidden');
                timerDisplay.classList.add('hidden');
                hintArea.classList.add('hidden');
                playerInfoBox.classList.add('hidden');
                renderWordDisplay();
                renderKeyboard(true);
                updateHangmanDrawing();
                wrongGuessesDisplay.textContent = '';
                gameMessage.classList.add('hidden');
            }

            function handleGuessLocal(button) {
                const letter = button.dataset.letter;
                button.disabled = true;
                guessedLetters.push(letter);
                if (secretWord.includes(letter)) {
                    playSound('correct');
                    renderWordDisplay();
                    button.classList.add('bg-green-500','text-white');
                } else {
                    playSound('wrong');
                    wrongGuesses++;
                    updateWrongGuessesDisplay();
                    updateHangmanDrawing();
                    button.classList.add('bg-red-500','text-white');
                }
                const allLettersGuessed = secretWord.split('').every(char => char === ' ' || guessedLetters.includes(char));
                if (allLettersGuessed) { playSound('win'); endGame(true); }
                else if (wrongGuesses >= maxWrongGuesses) { playSound('lose'); endGame(false); }
            }

            // --- ONLINE GAME FUNCTIONS ---
            async function createGame() {
                const playerName = createNameInput.value.trim();
                if (playerName.length < 2) { showError("Please enter a name (at least 2 characters)."); return; }
                disableOnlineButtons();
                const playerAvatar = avatarColors[createAvatarIndex];
                try {
                    const gameCollection = collection(db, `artifacts/${appId}/public/data/hangmanGames`);
                    const gameDoc = await addDoc(gameCollection, {
                        creatorId: userId,
                        guesserId: null,
                        players: { [userId]: { name: playerName, score: 0, avatar: playerAvatar } },
                        currentWordSetter: userId,
                        currentGuesser: null,
                        gameState: 'setting_rounds',
                        totalRounds: 0,
                        currentRound: 0,
                        secretWord: '',
                        guessedLetters: [],
                        wrongGuesses: 0,
                        lastWinnerId: null,
                        lastEmoji: { emoji: '', timestamp: null },
                        roundEndTime: null,
                        hintUsed: false
                    });
                    currentGameId = gameDoc.id;
                    isGameCreator = true;
                    hideAllScreens();
                    roundSelectionScreen.classList.remove('hidden');
                    attachGameListener(currentGameId);
                } catch (e) {
                    showError("Failed to create game. Please try again.");
                    enableOnlineButtons();
                }
            }

            async function setRounds() {
                let numRounds;
                if (selectedRounds === 'custom') {
                    numRounds = parseInt(customRoundsInput.value, 10);
                    if (isNaN(numRounds) || numRounds < 1 || numRounds > 99) {
                        showError("Please enter a valid number of rounds (1-99).", false);
                        return;
                    }
                } else {
                    numRounds = parseInt(selectedRounds, 10);
                }
                setRoundsBtn.disabled = true;
                try {
                    const gameRef = doc(db, `artifacts/${appId}/public/data/hangmanGames`, currentGameId);
                    await updateDoc(gameRef, { totalRounds: numRounds, gameState: 'waiting_for_guesser' });
                    gameIdDisplay.value = currentGameId;
                    hideAllScreens();
                    waitingScreen.classList.remove('hidden');
                } catch (e) {
                    showError("Failed to set rounds. Please try again.", false);
                } finally { setRoundsBtn.disabled = false; }
            }

            async function joinGame() {
                const gameId = joinGameIdInput.value.trim();
                const playerName = joinNameInput.value.trim();
                if (playerName.length < 2) { showError("Please enter a name (at least 2 characters)."); return; }
                if (gameId.length === 0) { showError('Please enter a Game ID to join.'); return; }
                disableOnlineButtons();
                try {
                    const gameRef = doc(db, `artifacts/${appId}/public/data/hangmanGames`, gameId);
                    const gameSnap = await getDoc(gameRef);
                    if (!gameSnap.exists()) { showError('Game not found. Check the ID and try again.'); enableOnlineButtons(); return; }
                    const gameData = gameSnap.data();
                    if (gameData.guesserId && gameData.guesserId !== userId) { showError('This game is already full.'); enableOnlineButtons(); return; }
                    let players = gameData.players;
                    const playerAvatar = avatarColors[joinAvatarIndex];
                    if (!players[userId]) players[userId] = { name: playerName, score: 0, avatar: playerAvatar };
                    await updateDoc(gameRef, { guesserId: userId, currentGuesser: userId, players: players, gameState: 'waiting_for_word', currentRound: 1 });
                    currentGameId = gameId;
                    isGameCreator = false;
                    joinGameIdInput.value = '';
                    joinNameInput.value = '';
                    attachGameListener(currentGameId);
                } catch (e) {
                    showError("Failed to join game. Please try again.");
                    enableOnlineButtons();
                }
            }

            function attachGameListener(gameId) {
                const gameRef = doc(db, `artifacts/${appId}/public/data/hangmanGames`, gameId);
                if (gameUnsubscribe) gameUnsubscribe();
                gameUnsubscribe = onSnapshot(gameRef, (docSnap) => {
                    if (!docSnap.exists()) { showError("The game was canceled or deleted."); resetGame(); return; }
                    const oldData = currentRoomData;
                    currentRoomData = docSnap.data();
                    const data = currentRoomData;
                    if (data.lastEmoji && data.lastEmoji.timestamp && (!oldData.lastEmoji || data.lastEmoji.timestamp !== oldData.lastEmoji.timestamp) && data.lastEmoji.senderId !== userId) {
                        showEmojiReaction(data.lastEmoji.emoji);
                    }
                    secretWord = data.secretWord;
                    guessedLetters = data.guessedLetters || [];
                    wrongGuesses = data.wrongGuesses || 0;
                    const amIWordSetter = userId === data.currentWordSetter;
                    const amIGuesser = userId === data.currentGuesser;

                    // Show appropriate UI elements based on game state
                    if (data.gameState !== 'setting_rounds' && data.gameState !== 'waiting_for_guesser') {
                        showGameScreens();
                    } else {
                        // Explicitly hide side panels for setup screens
                        chatToggleBtn.classList.add('hidden');
                        chatToggleBtn.style.display = 'none';
                        playerInfoBox.classList.add('hidden');
                        chatWindowDesktop.classList.add('hidden');
                        chatWindowDesktop.style.display = 'none';
                    }

                    if (data.gameState === 'playing' || data.gameState === 'game_over' || data.gameState === 'waiting_for_word') {
                        renderScoreDisplay();
                    }

                    switch (data.gameState) {
                        case 'setting_rounds':
                            if (amIWordSetter) { hideAllScreens(); roundSelectionScreen.classList.remove('hidden'); }
                            else { hideAllScreens(); onlineSetupScreen.classList.remove('hidden'); showError("Waiting for host to set up match..."); }
                            break;
                        case 'waiting_for_guesser':
                            hideAllScreens();
                            waitingScreen.classList.remove('hidden');
                            break;
                        case 'waiting_for_word':
                            hideAllScreens();
                            showGameScreens();
                            timerDisplay.classList.add('hidden');
                            playerInfoTimer.classList.add('hidden');
                            stopRoundTimer();
                            resetClockHands();
                            if (amIWordSetter) setWordScreen.classList.remove('hidden');
                            else waitForWordScreen.classList.remove('hidden');
                            break;
                        case 'playing':
                            hideAllScreens();
                            gameScreen.classList.remove('hidden');
                            showGameScreens();
                            timerDisplay.classList.remove('hidden');
                            playerInfoTimer.classList.remove('hidden');
                            gameMessage.classList.add('hidden');
                            startRoundTimer(data.roundEndTime);
                            renderWordDisplay();
                            renderKeyboard(amIGuesser);
                            updateHangmanDrawing();
                            updateWrongGuessesDisplay();
                            break;
                        case 'game_over':
                            hideAllScreens();
                            gameScreen.classList.remove('hidden');
                            showGameScreens();
                            timerDisplay.classList.remove('hidden');
                            playerInfoTimer.classList.remove('hidden');
                            stopRoundTimer();
                            renderWordDisplay();
                            renderKeyboard(false);
                            updateHangmanDrawing();
                            updateWrongGuessesDisplay();
                            if (data.currentRound >= data.totalRounds) endGame(data.lastWinnerId === userId, true);
                            else endGame(data.lastWinnerId === userId, false);
                            break;
                        case 'leaderboard':
                            hideAllScreens();
                            leaderboardScreen.classList.remove('hidden');
                            showGameScreens();
                            renderLeaderboard();
                            break;
                    }
                });

                // chat listener
                const chatCollection = collection(db, `artifacts/${appId}/public/data/hangmanGames`, gameId, 'messages');
                const q = query(chatCollection, orderBy("timestamp", "desc"));
                if (chatUnsubscribe) chatUnsubscribe();
                chatUnsubscribe = onSnapshot(q, (querySnapshot) => {
                    chatMessagesMobile.innerHTML = '';
                    chatMessagesDesktop.innerHTML = '';
                    querySnapshot.docs.reverse().forEach(doc => renderChatMessage(doc.data()));
                });
            }

            async function setOnlineWord() {
                const word = onlineSecretWordInput.value.trim().toUpperCase();
                if (!validateWord(word, false)) return;
                setOnlineWordBtn.disabled = true;
                try {
                    const gameRef = doc(db, `artifacts/${appId}/public/data/hangmanGames`, currentGameId);
                    const roundEndTime = Date.now() + ROUND_DURATION;
                    await updateDoc(gameRef, { secretWord: word, guessedLetters: [...vowels], wrongGuesses: 0, gameState: 'playing', roundEndTime: roundEndTime, hintUsed: false });
                    onlineSecretWordInput.value = '';
                } catch (e) {
                    showError("Failed to set word. Please try again.", false);
                } finally { setOnlineWordBtn.disabled = false; }
            }

            async function handleGuessOnline(button) {
                const letter = button.dataset.letter;
                if (guessedLetters.includes(letter)) return;
                button.disabled = true;
                let newGuessedLetters = [...guessedLetters, letter];
                let newWrongGuesses = wrongGuesses;
                let newStatus = 'playing';
                let newWinnerId = null;
                let newScores = currentRoomData.players || {};
                if (secretWord.includes(letter)) { playSound('correct'); }
                else { playSound('wrong'); newWrongGuesses++; }
                const allLettersGuessed = secretWord.split('').every(char => char === ' ' || newGuessedLetters.includes(char));
                if (allLettersGuessed) {
                    newStatus = 'game_over';
                    newWinnerId = currentRoomData.currentGuesser;
                    newScores[newWinnerId].score++;
                    playSound('win');
                } else if (newWrongGuesses >= maxWrongGuesses) {
                    newStatus = 'game_over';
                    newWinnerId = currentRoomData.currentWordSetter;
                    newScores[newWinnerId].score++;
                    playSound('lose');
                }
                try {
                    const gameRef = doc(db, `artifacts/${appId}/public/data/hangmanGames`, currentGameId);
                    await updateDoc(gameRef, { guessedLetters: newGuessedLetters, wrongGuesses: newWrongGuesses, gameState: newStatus, lastWinnerId: newWinnerId, players: newScores });
                } catch (e) {
                    showError("Error submitting guess. Please try again.", false);
                    button.disabled = false;
                }
            }

            async function handleHintRequest() {
                if (currentRoomData.hintUsed || currentRoomData.gameState !== 'playing') return;
                const remainingTime = currentRoomData.roundEndTime - Date.now();
                const hintAvailableTime = ROUND_DURATION - 60000;
                if (remainingTime > hintAvailableTime) {
                    hintBtn.disabled = true;
                    hintBtn.textContent = `üí° Hint in ${Math.ceil((remainingTime - hintAvailableTime) / 1000)}s`;
                    setTimeout(() => {
                        if (currentRoomData.gameState === 'playing' && !currentRoomData.hintUsed) {
                            hintBtn.disabled = false;
                            hintBtn.textContent = "üí° Get Hint (1 left)";
                        }
                    }, (remainingTime - hintAvailableTime) + 100);
                    return;
                }
                const availableHints = secretWord.split('').filter(char => consonants.includes(char) && !guessedLetters.includes(char));
                if (availableHints.length === 0) {
                    hintBtn.disabled = true;
                    hintBtn.textContent = "No Hints Left";
                    return;
                }
                hintBtn.disabled = true;
                const hintLetter = availableHints[Math.floor(Math.random() * availableHints.length)];
                let newGuessedLetters = [...guessedLetters, hintLetter];
                let newStatus = 'playing';
                let newWinnerId = null;
                let newScores = currentRoomData.players || {};
                playSound('correct');
                const allLettersGuessed = secretWord.split('').every(char => char === ' ' || newGuessedLetters.includes(char));
                if (allLettersGuessed) {
                    newStatus = 'game_over';
                    newWinnerId = currentRoomData.currentGuesser;
                    newScores[newWinnerId].score++;
                    playSound('win');
                }
                try {
                    const gameRef = doc(db, `artifacts/${appId}/public/data/hangmanGames`, currentGameId);
                    await updateDoc(gameRef, { guessedLetters: newGuessedLetters, gameState: newStatus, lastWinnerId: newWinnerId, players: newScores, hintUsed: true });
                } catch (e) {
                    showError("Error using hint. Please try again.", false);
                    hintBtn.disabled = false;
                }
            }

            async function startNextRound() {
                playAgainBtn.disabled = true;
                try {
                    const gameRef = doc(db, `artifacts/${appId}/public/data/hangmanGames`, currentGameId);
                    await updateDoc(gameRef, {
                        currentWordSetter: currentRoomData.currentGuesser,
                        currentGuesser: currentRoomData.currentWordSetter,
                        currentRound: currentRoomData.currentRound + 1,
                        gameState: 'waiting_for_word',
                        secretWord: '',
                        guessedLetters: [],
                        wrongGuesses: 0,
                        lastWinnerId: null,
                        roundEndTime: null,
                        hintUsed: false
                    });
                } catch (e) { showError("Error starting next round. Please try again.", false); } finally { playAgainBtn.disabled = false; }
            }

            async function startNewMatch() {
                playAgainMatchBtn.disabled = true;
                try {
                    const gameRef = doc(db, `artifacts/${appId}/public/data/hangmanGames`, currentGameId);
                    const players = currentRoomData.players || {};
                    for (const pid in players) { players[pid].score = 0; }
                    await updateDoc(gameRef, {
                        players: players,
                        gameState: 'setting_rounds',
                        currentRound: 0,
                        totalRounds: 0,
                        currentWordSetter: currentRoomData.creatorId,
                        currentGuesser: currentRoomData.guesserId,
                        secretWord: '',
                        guessedLetters: [],
                        wrongGuesses: 0,
                        lastWinnerId: null,
                        roundEndTime: null,
                        hintUsed: false
                    });
                } catch (e) { showError("Error starting new match.", false); playAgainMatchBtn.disabled = false; }
            }

            // Timer functions
            function startRoundTimer(endTime) {
                stopRoundTimer();
                function updateTimerDisplay(remainingMs) {
                    const minutes = Math.floor(remainingMs / 60000);
                    const seconds = Math.floor((remainingMs % 60000) / 1000);
                    const timeString = `${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}`;
                    timerText.textContent = timeString;
                    playerInfoTimerText.textContent = timeString;
                }
                const timeNow = Date.now();
                const remainingMs = endTime - timeNow;
                updateTimerDisplay(remainingMs);
                const timePassed = ROUND_DURATION - remainingMs;
                const initialRotation = (timePassed / ROUND_DURATION) * 360;
                clockHandMobile.style.transform = `rotate(${initialRotation}deg)`;
                clockHandDesktop.style.transform = `rotate(${initialRotation}deg)`;
                clockHandMobile.style.animation = 'none';
                clockHandDesktop.style.animation = 'none';
                void clockHandMobile.offsetHeight;
                clockHandMobile.style.animation = `clock-tick ${ROUND_DURATION / 1000}s linear forwards`;
                clockHandDesktop.style.animation = `clock-tick ${ROUND_DURATION / 1000}s linear forwards`;
                clockHandMobile.style.animationDelay = `-${timePassed / 1000}s`;
                clockHandDesktop.style.animationDelay = `-${timePassed / 1000}s`;
                clockHandMobile.style.animationPlayState = 'running';
                clockHandDesktop.style.animationPlayState = 'running';
                roundTimerInterval = setInterval(() => {
                    const remainingMs = endTime - Date.now();
                    if (remainingMs <= 0) {
                        stopRoundTimer();
                        updateTimerDisplay(0);
                        if (userId === currentRoomData.currentGuesser && currentRoomData.gameState === 'playing') handleTimeUp();
                        return;
                    }
                    updateTimerDisplay(remainingMs);
                }, 1000);
            }
            function stopRoundTimer() { if (roundTimerInterval) { clearInterval(roundTimerInterval); roundTimerInterval = null; } clockHandMobile.style.animationPlayState = 'paused'; clockHandDesktop.style.animationPlayState = 'paused'; }
            function resetClockHands() { clockHandMobile.style.animation = 'none'; clockHandDesktop.style.animation = 'none'; clockHandMobile.style.transform = 'rotate(0deg)'; clockHandDesktop.style.transform = 'rotate(0deg)'; }
            async function handleTimeUp() {
                const newScores = currentRoomData.players || {};
                const winnerId = currentRoomData.currentWordSetter;
                newScores[winnerId].score++;
                playSound('lose');
                try {
                    const gameRef = doc(db, `artifacts/${appId}/public/data/hangmanGames`, currentGameId);
                    await updateDoc(gameRef, { gameState: 'game_over', lastWinnerId: winnerId, players: newScores });
                } catch (e) { showError("Error finalizing round. Please try again.", false); }
            }

            // Common game functions
            function validateWord(word, onSetup = true) {
                if (word.length === 0) { showError('Please enter a word or phrase.', onSetup); return false; }
                const hasConsonant = word.split('').every(char => char === ' ' || vowels.includes(char));
                if (hasConsonant) { showError('Please enter a word with at least one consonant.', onSetup); return false; }
                return true;
            }

            function renderScoreDisplay() {
                if (gameMode !== 'online' || !currentRoomData.players || !userId) { scoreDisplayMobile.classList.add('hidden'); playerInfoBox.classList.add('hidden'); return; }
                const myPlayer = currentRoomData.players[userId];
                const opponentId = (userId === currentRoomData.creatorId) ? currentRoomData.guesserId : currentRoomData.creatorId;
                const opponentPlayer = currentRoomData.players[opponentId];
                const myName = myPlayer?.name || "You";
                const myScore = myPlayer?.score || 0;
                const myAvatar = myPlayer?.avatar || avatarColors[0];
                const opponentName = opponentPlayer?.name || "Waiting...";
                const opponentScore = opponentPlayer?.score || 0;
                const opponentAvatar = opponentPlayer?.avatar || avatarColors[1];
                const amIWordSetter = userId === currentRoomData.currentWordSetter;
                scoreText.textContent = `${myName}: ${myScore}  -  ${opponentName}: ${opponentScore}`;
                roundText.textContent = `Round ${currentRoomData.currentRound} / ${currentRoomData.totalRounds}`;
                playerInfoRound.innerHTML = `<svg class="w-6 h-6 text-indigo-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg><span>Round ${currentRoomData.currentRound} / ${currentRoomData.totalRounds}</span>`;
                playerInfoMeAvatar.style.backgroundColor = myAvatar;
                playerInfoMeName.textContent = myName;
                playerInfoMeScore.textContent = myScore;
                playerInfoFriendAvatar.style.backgroundColor = opponentAvatar;
                playerInfoFriendName.textContent = opponentName;
                playerInfoFriendScore.textContent = opponentScore;
                playerInfoMeCrown.classList.toggle('hidden', !amIWordSetter);
                playerInfoFriendCrown.classList.toggle('hidden', amIWordSetter);
                playerInfoMe.classList.toggle('active-player', amIWordSetter);
                playerInfoFriend.classList.toggle('active-player', !amIWordSetter);
            }

            function renderWordDisplay() {
                wordDisplay.innerHTML = '';
                secretWord.split('').forEach(char => {
                    const letterSpan = document.createElement('span');
                    letterSpan.classList.add('font-extrabold','text-2xl','md:text-4xl','uppercase');
                    if (char === ' ') { letterSpan.classList.add('w-4','md:w-6'); letterSpan.innerHTML = '&nbsp;'; }
                    else if (guessedLetters.includes(char)) { letterSpan.textContent = char; letterSpan.classList.add('text-indigo-900'); }
                    else { letterSpan.textContent = '_'; letterSpan.classList.add('text-indigo-300'); }
                    wordDisplay.appendChild(letterSpan);
                });
            }

            function renderKeyboard(canGuess) {
                keyboardArea.innerHTML = '';
                if (canGuess) {
                    hintArea.classList.remove('hidden');
                    keyboardArea.appendChild(hintArea);
                    const remainingTime = (currentRoomData.roundEndTime || 0) - Date.now();
                    const hintAvailableTime = ROUND_DURATION - 60000;
                    if (currentRoomData.hintUsed) { hintBtn.disabled = true; hintBtn.textContent = "üí° Hint Used"; }
                    else if (remainingTime <= hintAvailableTime) { hintBtn.disabled = false; hintBtn.textContent = "üí° Get Hint (1 left)"; }
                    else { hintBtn.disabled = true; const secondsLeft = Math.ceil((remainingTime - hintAvailableTime) / 1000); hintBtn.textContent = `üí° Hint in ${secondsLeft}s`; setTimeout(() => { if (currentRoomData.gameState === 'playing' && !currentRoomData.hintUsed) { hintBtn.disabled = false; hintBtn.textContent = "üí° Get Hint (1 left)"; } }, (remainingTime - hintAvailableTime) + 100); }
                    keyboardArea.appendChild(keyboardButtons);
                    spectatorView.classList.add('hidden');
                    keyboardButtons.innerHTML = '';
                    consonants.forEach(letter => {
                        const button = document.createElement('button');
                        button.textContent = letter;
                        button.classList.add('keyboard-button','w-12','h-12','md:w-14','md:h-14','bg-indigo-500','text-white','font-extrabold','text-xl','rounded-lg','shadow-md');
                        button.dataset.letter = letter;
                        if (guessedLetters.includes(letter)) {
                            button.disabled = true;
                            if (secretWord.includes(letter)) button.classList.add('bg-green-500','text-white');
                            else button.classList.add('bg-red-500','text-white');
                        }
                        button.addEventListener('click', () => {
                            if (gameMode === 'local') handleGuessLocal(button);
                            else if (gameMode === 'online' && canGuess) handleGuessOnline(button);
                        });
                        keyboardButtons.appendChild(button);
                    });
                } else {
                    hintArea.classList.add('hidden');
                    keyboardArea.appendChild(spectatorView);
                    spectatorView.classList.remove('hidden');
                }
            }

            function updateWrongGuessesDisplay() {
                const wrongLetters = guessedLetters.filter(letter => !secretWord.includes(letter) && !vowels.includes(letter));
                wrongGuessesDisplay.textContent = wrongLetters.join(', ');
            }

            function updateHangmanDrawing() {
                hangmanParts.forEach(partId => {
                    if (document.getElementById(partId)) document.getElementById(partId).style.visibility = 'hidden';
                });
                for (let i = 0; i < wrongGuesses; i++) {
                    if (hangmanParts[i] && document.getElementById(hangmanParts[i])) {
                        document.getElementById(hangmanParts[i]).style.visibility = 'visible';
                    }
                }
            }

            function endGame(isWin, isMatchOver = false) {
                stopRoundTimer();
                if (isWin) {
                    messageText.textContent = 'YOU WIN!';
                    messageText.classList.add('text-green-600','bg-gradient-to-r','from-cyan-500','to-blue-500','animate-pulse');
                    messageText.style.backgroundImage = 'linear-gradient(to right, var(--tw-gradient-stops))';
                    fireConfetti();
                    if (currentRoomData.gameState !== 'game_over') playSound('win');
                } else {
                    messageText.textContent = 'GAME OVER!';
                    messageText.classList.add('text-red-600');
                    guessedLetters = [...secretWord.split('')];
                    renderWordDisplay();
                    if (currentRoomData.gameState !== 'game_over') playSound('lose');
                }
                if (gameMode === 'local') playAgainBtn.textContent = 'Play Again';
                else if (isMatchOver) playAgainBtn.textContent = 'View Results';
                else playAgainBtn.textContent = 'Next Round';
                gameMessage.classList.remove('hidden');
            }

            async function handlePlayAgain() {
                if (gameMode === 'local') resetGame();
                else {
                    if (currentRoomData.currentRound >= currentRoomData.totalRounds) {
                        try { const gameRef = doc(db, `artifacts/${appId}/public/data/hangmanGames`, currentGameId); await updateDoc(gameRef, { gameState: 'leaderboard' }); }
                        catch (e) { showError("Error showing leaderboard.", false); }
                    } else {
                        startNextRound();
                    }
                }
            }

            function renderLeaderboard() {
                const myPlayer = currentRoomData.players[userId];
                const opponentId = (userId === currentRoomData.creatorId) ? currentRoomData.guesserId : currentRoomData.creatorId;
                const opponentPlayer = currentRoomData.players[opponentId];
                const myName = myPlayer?.name || "You";
                const myScore = myPlayer?.score || 0;
                const myAvatar = myPlayer?.avatar || avatarColors[0];
                const opponentName = opponentPlayer?.name || "Friend";
                const opponentScore = opponentPlayer?.score || 0;
                const opponentAvatar = opponentPlayer?.avatar || avatarColors[1];
                const player1 = (myScore >= opponentScore) ? myPlayer : opponentPlayer;
                const player2 = (myScore < opponentScore) ? myPlayer : opponentPlayer;
                finalAvatar1.style.backgroundColor = player1?.avatar || avatarColors[0];
                finalName1.textContent = player1?.name || "Player 1";
                finalScoreVal1.textContent = player1?.score || 0;
                finalAvatar2.style.backgroundColor = player2?.avatar || avatarColors[1];
                finalName2.textContent = player2?.name || "Player 2";
                finalScoreVal2.textContent = player2?.score || 0;
                if (myScore > opponentScore) { winnerAnnouncement.textContent = `Congratulations, ${myName}!`; winnerAnnouncement.classList.remove('text-red-600','text-gray-600'); winnerAnnouncement.classList.add('text-green-600'); fireConfetti(); }
                else if (opponentScore > myScore) { winnerAnnouncement.textContent = `${opponentName} Wins!`; winnerAnnouncement.classList.remove('text-green-600','text-gray-600'); winnerAnnouncement.classList.add('text-red-600'); }
                else { winnerAnnouncement.textContent = "It's a Tie!"; winnerAnnouncement.classList.remove('text-green-600','text-red-600'); winnerAnnouncement.classList.add('text-gray-600'); }
                if (isGameCreator) { playAgainMatchBtn.classList.remove('hidden'); waitingForHostRematch.classList.add('hidden'); }
                else { playAgainMatchBtn.classList.add('hidden'); waitingForHostRematch.classList.remove('hidden'); }
            }

            function resetGame() {
                if (gameMode === 'online') {
                    if (gameUnsubscribe) gameUnsubscribe();
                    if (chatUnsubscribe) chatUnsubscribe();
                    gameUnsubscribe = null; chatUnsubscribe = null;
                }
                stopRoundTimer();
                resetClockHands();
                secretWord = ''; guessedLetters = []; wrongGuesses = 0; currentGameId = null; isGameCreator = false; currentRoomData = {}; gameMode = 'local'; selectedRounds = 3;
                hideAllScreens();
                modeSelectionScreen.classList.remove('hidden');
                gameMessage.classList.add('hidden');
                wrongGuessesDisplay.textContent = '';
                updateHangmanDrawing();
                createNameInput.value = ''; joinNameInput.value = '';
                if (isFirebaseInitialized) enableOnlineButtons();
                messageText.classList.remove('text-green-600','text-red-600','bg-gradient-to-r','from-cyan-500','to-blue-5g00','animate-pulse');
                messageText.style.backgroundImage = '';
            }

            async function cancelGame() {
                if (!currentGameId) { resetGame(); return; }
                cancelGameBtn.disabled = true;
                try {
                    const gameRef = doc(db, `artifacts/${appId}/public/data/hangmanGames`, currentGameId);
                    await deleteDoc(gameRef);
                } catch (e) { }
                finally { resetGame(); cancelGameBtn.disabled = false; }
            }

            function copyToClipboard(text, button, defaultText = 'Copy') {
                try {
                    const ta = document.createElement('textarea');
                    ta.value = text;
                    ta.style.position = 'fixed';
                    ta.style.left = '-9999px';
                    document.body.appendChild(ta);
                    ta.select();
                    document.execCommand('copy');
                    document.body.removeChild(ta);
                    button.textContent = 'Copied!';
                } catch (err) { button.textContent = 'Copy Failed'; }
                setTimeout(() => { button.textContent = defaultText; }, 2000);
            }

            function fireConfetti() {
                if (typeof confetti !== 'function') return;
                const duration = 3 * 1000;
                const animationEnd = Date.now() + duration;
                const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 0 };
                function randomInRange(min,max) { return Math.random() * (max - min) + min; }
                const interval = setInterval(function() {
                    const timeLeft = animationEnd - Date.now();
                    if (timeLeft <= 0) return clearInterval(interval);
                    const particleCount = 50 * (timeLeft / duration);
                    confetti(Object.assign({}, defaults, { particleCount, origin: { x: randomInRange(0.1,0.3), y: Math.random() - 0.2 } }));
                    confetti(Object.assign({}, defaults, { particleCount, origin: { x: randomInRange(0.7,0.9), y: Math.random() - 0.2 } }));
                }, 250);
            }

            // Chat functions
            function toggleChatPopup() {
                if (!chatPopupMobile) return;
                chatPopupMobile.classList.toggle('hidden');
                setTimeout(() => {
                    chatPopupMobile.classList.toggle('scale-0');
                    chatPopupMobile.classList.toggle('scale-100');
                    if (!chatPopupMobile.classList.contains('hidden')) chatPopupMobile.style.display = 'flex';
                    else chatPopupMobile.style.display = 'none';
                }, 10);
            }

            async function handleChatSubmit(e) {
                e.preventDefault();
                const isMobile = e.target.id === 'chat-form-mobile';
                const input = isMobile ? chatInputMobile : chatInputDesktop;
                const messageText = input.value.trim();
                if (messageText.length === 0) return;
                if (secretWord && messageText.toUpperCase().includes(secretWord) && secretWord.length > 2) {
                    input.value = ''; showChatError("You can't send the secret word!"); return;
                }
                await sendChatMessage(messageText);
                input.value = '';
            }

            async function handleEmojiClick(e) {
                if (e.target.classList.contains('emoji-reaction-btn-mobile') || e.target.classList.contains('emoji-reaction-btn-desktop')) {
                    const emoji = e.target.dataset.emoji;
                    await sendChatMessage(emoji, true);
                }
            }

            async function sendChatMessage(text, isEmoji = false) {
                if (!currentGameId || !userId) return;
                try {
                    const chatCollection = collection(db, `artifacts/${appId}/public/data/hangmanGames`, currentGameId, 'messages');
                    await addDoc(chatCollection, { text: text, senderId: userId, isEmoji: isEmoji, timestamp: serverTimestamp() });
                    if (isEmoji) {
                        const gameRef = doc(db, `artifacts/${appId}/public/data/hangmanGames`, currentGameId);
                        await updateDoc(gameRef, { lastEmoji: { emoji: text, senderId: userId, timestamp: Date.now() } });
                    }
                } catch (e) { console.error("Error sending message: ", e); showChatError("Error sending message."); }
            }

            function renderChatMessage(data) {
                if (!data) return;
                [chatMessagesMobile, chatMessagesDesktop].forEach(chatBox => {
                    if (!chatBox) return;
                    const isMe = data.senderId === userId;
                    const playerData = currentRoomData.players && currentRoomData.players[data.senderId];
                    const playerName = playerData?.name || "Player";
                    const playerColor = playerData?.avatar || "#6B7280";
                    const msgDiv = document.createElement('div');
                    if (data.isEmoji) {
                        msgDiv.classList.add('text-5xl', isMe ? 'text-right' : 'text-left');
                        msgDiv.textContent = data.text;
                    } else {
                        msgDiv.classList.add('w-full','flex','flex-col', isMe ? 'items-end' : 'items-start');
                        const nameSpan = document.createElement('span');
                        nameSpan.classList.add('text-xs','font-semibold','mb-1','px-2');
                        nameSpan.textContent = isMe ? "You" : playerName;
                        nameSpan.style.color = isMe ? '#4F46E5' : playerColor;
                        const bubble = document.createElement('div');
                        bubble.classList.add('p-3','rounded-2xl','max-w-[75%]','shadow','break-words');
                        bubble.textContent = data.text;
                        if (isMe) bubble.classList.add('bg-indigo-500','text-white','rounded-br-none');
                        else bubble.classList.add('bg-gray-200','text-gray-800','rounded-bl-none');
                        msgDiv.appendChild(nameSpan);
                        msgDiv.appendChild(bubble);
                    }
                    chatBox.appendChild(msgDiv);
                    chatBox.scrollTop = chatBox.scrollHeight;
                });
            }

            function showChatError(message) {
                [chatMessagesMobile, chatMessagesDesktop].forEach(chatBox => {
                    if (!chatBox) return;
                    const errorDiv = document.createElement('div');
                    errorDiv.classList.add('w-full','text-center','text-red-500','text-sm','italic');
                    errorDiv.textContent = message;
                    chatBox.appendChild(errorDiv);
                    chatBox.scrollTop = chatBox.scrollHeight;
                });
            }

            function showEmojiReaction(emoji) {
                emojiDisplayArea.textContent = emoji;
                emojiDisplayArea.classList.add('pop-and-fade');
                setTimeout(() => { emojiDisplayArea.classList.remove('pop-and-fade'); emojiDisplayArea.textContent = ''; }, 2000);
            }

            // --- Initial Load ---
            checkUrlForGameId(); // Check for game invite on load
            updateAvatar(createAvatarDisplay, createAvatarIndex);
            updateAvatar(joinAvatarDisplay, joinAvatarIndex);
            
            // MANUALLY HIDE DESKTOP PANELS ON LOAD
            playerInfoBox.classList.add('hidden');
            chatWindowDesktop.classList.add('hidden');
            chatWindowDesktop.style.display = 'none'; // Force hide

        }); // End of DOMContentLoaded
    </script>
</body>
</html>
